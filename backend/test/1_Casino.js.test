const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Casino contract testing", function () {
  const TOKEN_PRICE = ethers.parseEther("0.00003");

  async function deployCasinoFixture() {
    const [owner, user1] = await ethers.getSigners();

    // Déployer le MockVRFCoordinator
    const MockVRFCoordinator = await ethers.getContractFactory(
      "VRFCoordinatorV2_5Mock"
    );
    const mockVRFCoordinator = await MockVRFCoordinator.deploy(
      ethers.parseEther("0.1"), // Base fee
      1e9, // Gas price link
      ethers.parseEther("0.000001") // Wei per unit link (ajustez selon vos besoins)
    );

    const mockVRFCoordinatorAddress = await mockVRFCoordinator.getAddress();

    // Déployer le contrat Casino en utilisant l'adresse du MockVRFCoordinator
    const Casino = await ethers.getContractFactory("Casino");
    const casino = await Casino.deploy(mockVRFCoordinatorAddress);

    // // Créer un abonnement
    // const createSubTx = await mockVRFCoordinator.createSubscription();
    // // const createSubReceipt = await createSubTx.wait(1);
    // // const subId = createSubReceipt.events[0].args.subId;
    // const transactionReceipt = await createSubTx.wait(1);
    // const subscriptionId = ethers.BigNumber.from(
    //   transactionReceipt.events[0].topics[1]
    // );

    // // Financer l'abonnement
    // await mockVRFCoordinator.fundSubscription(
    //   subscriptionId,
    //   ethers.parseEther("1")
    // );

    // // Ajouter le consommateur (votre contrat Casino)
    // await mockVRFCoordinator.addConsumer(subId, casino.getAddress());

    // // Mettre à jour le subId dans votre contrat Casino si nécessaire
    // // await casino.updateSubscriptionId(subId);

    // token
    const tokenAddress = await casino.tokenAddress();
    const CasinoToken = await ethers.getContractFactory("CasinoToken");
    const token = CasinoToken.attach(tokenAddress);

    // Acheter des jetons pour l'utilisateur
    await casino
      .connect(user1)
      .buyTokens(30000, { value: ethers.parseEther("1") });

    return {
      casino,
      token,
      owner,
      user1,
      mockVRFCoordinator,
      mockVRFCoordinatorAddress,
    };
  }

  describe.skip("Playing games", function () {
    it("Should emit RandomWordsRequested event", async function () {
      const { casino, token, user1 } = await loadFixture(deployCasinoFixture);
      await token.connect(user1).approve(casino, 10);

      await expect(casino.connect(user1).playGame(1, 10)).to.emit(
        casino,
        "RandomWordsRequested"
      );
    });
  });

  describe.only("Fixture testing", function () {
    it("Should deploy Casino contract with correct initial setup", async function () {
      const { casino, owner, mockVRFCoordinatorAddress } = await loadFixture(
        deployCasinoFixture
      );

      // Vérifier que l'adresse du MockVRFCoordinator est correcte
      expect(mockVRFCoordinatorAddress).to.properAddress;

      // Vérifier que le propriétaire est bien défini
      expect(await casino.owner()).to.equal(owner.address);
    });

    it("Should call fulfillRandomWords and verify the outcome", async function () {
      const { casino, token, user1, vrfCoordinatorV2Mock } = await loadFixture(
        deployCasinoFixture
      );
      await token.connect(user1).approve(casino, 10);

      // Jouer le jeu et obtenir le requestId
      const playGameTx = await casino.connect(user1).playGame(1, 10);
      const receipt = await playGameTx.wait();
      const requestId = receipt.events.find(
        (event) => event.event === "RandomWordsRequested"
      ).args.requestId;

      // Simuler la réponse VRF
      const randomWords = [12345];
      await vrfCoordinatorV2Mock.fulfillRandomWords(
        requestId,
        casino.address,
        randomWords
      );

      // Vérifier l'état après l'appel à fulfillRandomWords
      const player = await casino.players(user1.address);
      expect(player.nbGames).to.equal(1);
      // Ajoutez d'autres vérifications selon vos besoins
    });

    it("Should extract requestId from RandomWordsRequested event", async function () {
      const { casino, token, user1, mockVRFCoordinator } = await loadFixture(
        deployCasinoFixture
      );
      await token.connect(user1).approve(casino, 10);

      // Jouer le jeu et obtenir le requestId
      const playGameTx = await casino.connect(user1).playGame(1, 10);
      const receipt = await playGameTx.wait();
      const event = receipt.events.find(
        (event) => event.event === "RandomWordsRequested"
      );

      console.log("Event: ", event); // Ajouter cette ligne pour voir l'événement dans la console

      const requestId = event.args.requestId;

      console.log("RequestId: ", requestId); // Ajouter cette ligne pour voir le requestId dans la console

      // Vérifier que le requestId est défini
      expect(requestId).to.not.be.undefined;
      expect(requestId).to.not.be.null;
    });
  });

  describe.skip("Playing games", function () {
    it("Should play game if allowance is sufficient", async function () {
      const { casino, token, user1, mockVRFCoordinator } = await loadFixture(
        deployCasinoFixture
      );
      await token.connect(user1).approve(casino, 10);

      // Jouer le jeu et obtenir le requestId
      const playGameTx = await casino.connect(user1).playGame(1, 10);
      const receipt = await playGameTx.wait();
      const requestId = receipt.events.find(
        (event) => event.event === "RandomWordsRequested"
      ).args.requestId;

      // Simuler la réponse VRF
      const randomWords = [12345];
      await mockVRFCoordinator.fulfillRandomWords(
        requestId,
        casino.address,
        randomWords
      );

      await expect(playGameTx)
        .to.emit(casino, "PlayerPlayedGame")
        .withArgs(user1.address, 1, 10, 0);
    });

    it("Should store requestId and player data correctly", async function () {
      const { casino, token, user1, mockVRFCoordinator } = await loadFixture(
        deployCasinoFixture
      );
      await token.connect(user1).approve(casino, 10);

      // Jouer le jeu et obtenir le requestId
      const playGameTx = await casino.connect(user1).playGame(1, 10);
      const receipt = await playGameTx.wait();
      const requestId = receipt.events.find(
        (event) => event.event === "RandomWordsRequested"
      ).args.requestId;

      // Vérifier que les données sont correctement stockées
      expect(await casino.requestIdToPlayer(requestId)).to.equal(user1.address);
      expect(await casino.playerBetAmount(user1.address)).to.equal(10);
      expect(await casino.playerGameType(user1.address)).to.equal(1);
    });

    it("Should handle VRF response correctly", async function () {
      const { casino, token, user1, mockVRFCoordinator } = await loadFixture(
        deployCasinoFixture
      );
      await token.connect(user1).approve(casino, 10);

      // Jouer le jeu et obtenir le requestId
      const playGameTx = await casino.connect(user1).playGame(1, 10);
      const receipt = await playGameTx.wait();
      const requestId = receipt.events.find(
        (event) => event.event === "RandomWordsRequested"
      ).args.requestId;

      // Simuler la réponse VRF
      const randomWords = [12345];
      await mockVRFCoordinator.fulfillRandomWords(
        requestId,
        casino.address,
        randomWords
      );

      // Vérifier que le jeu a été traité correctement
      await expect(
        mockVRFCoordinator.fulfillRandomWords(
          requestId,
          casino.address,
          randomWords
        )
      )
        .to.emit(casino, "PlayerWon")
        .withArgs(user1.address, 10, 100);
    });
  });
});
